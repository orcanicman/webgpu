(()=>{"use strict";(async()=>{const[e,t,r]=await(async()=>{if(!navigator.gpu)throw Error("Can not initialize gpu");const e=(e=>{const t=document.createElement("canvas"),r=t.getContext("webgpu");if(!e)throw Error("Root element not found, please specify it.");if(!r)throw Error("Could not get the rendering context from canvas.");return e.appendChild(t),r})(document.getElementById("root")),t=await navigator.gpu.requestAdapter();if(!t)throw Error("Could not request adapter");const r=await t.requestDevice();if(!r)throw Error("Could not request device");const n=navigator.gpu.getPreferredCanvasFormat();return e.configure({device:r,format:n}),[e,r,n]})(),[n]=((e,t,r)=>{const n=t.createShaderModule({code:"struct VertexInput {\r\n    @location(0) position: vec2f, // OKAY SO, at the start of the program, the position is expected to be given to the vertex buffer which is at @location(0).\r\n}\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) position: vec4f, // After we are done with the input, we set the position to builtin\r\n    @location(0) color: vec4f, // And we set the color to @location(0) since that is what the function needs to return.\r\n}\r\n\r\n@vertex\r\nfn vertex_main(vert: VertexInput) -> VertexOutput {\r\n    var output: VertexOutput;\r\n    output.color = vec4f(1, 0, 0, 1);\r\n    output.position = vec4f(vert.position, 0.0, 1.0);\r\n\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn fragment_main(vert: VertexOutput) -> @location(0) vec4f {\r\n    return vert.color;\r\n}\r\n",label:"Shaders.wgsl"});return[t.createRenderPipeline({layout:"auto",vertex:{module:n,entryPoint:"vertex_main",buffers:[{arrayStride:8,attributes:[{format:"float32x2",offset:0,shaderLocation:0}]}]},fragment:{module:n,entryPoint:"fragment_main",targets:[{format:r}]}})]})(0,t,r);((e,t,r)=>{const n=e.createCommandEncoder(),o=n.beginRenderPass({colorAttachments:[{view:t.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:.5,g:.5,b:.5,a:1},storeOp:"store"}]}),a=(e=>{const t=e.x,r=e.x+e.width,n=e.y,o=e.y+e.height;return new Float32Array([t,n,r,n,t,o,t,o,r,n,r,o])})({x:0,y:0,width:.8,height:.8}),i=e.createBuffer({label:"vertecies",size:a.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});e.queue.writeBuffer(i,0,a),o.setPipeline(r),o.setVertexBuffer(0,i),o.draw(a.length/2),o.end();const u=n.finish();e.queue.submit([u])})(t,e,n)})()})();