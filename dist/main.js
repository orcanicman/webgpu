(()=>{"use strict";class e{static createVertexBuffer(e,t){const r=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new Float32Array(r.getMappedRange()).set(t),r.unmap(),r}static createResolutionBuffer(e,t){const r=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new Float32Array(r.getMappedRange()).set(t),r.unmap(),r}static createIndexBuffer(e,t){const r=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new Uint16Array(r.getMappedRange()).set(t),r.unmap(),r}}class t{vertices;inidices;constructor(){this.vertices=[300,250,0,1,1,1,1,380,250,1,1,1,1,1,380,330,1,0,1,1,1,300,330,0,0,1,1,1],this.inidices=[0,1,2,0,3,2]}}class r{texture;sampler;constructor(e,t){this.texture=e,this.sampler=t}static async createTexture(e,t){const n=e.createTexture({size:{width:t.width,height:t.height},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}),o=await createImageBitmap(t);e.queue.copyExternalImageToTexture({source:o},{texture:n},{width:t.width,height:t.height});const a=e.createSampler({magFilter:"nearest",minFilter:"linear"});return new r(n,a)}static async createTextureFromURL(e,t){const n=new Promise(((e,r)=>{const n=new Image;n.src=t,n.onload=()=>e(n),n.onerror=()=>{console.error(`Failed to load image ${t}`),r()}})),o=await n;return r.createTexture(e,o)}}(async()=>{const[n,o,a]=await(async()=>{if(!navigator.gpu)throw Error("Can not initialize gpu");const e=(e=>{const t=document.createElement("canvas");t.width=800,t.height=600;const r=t.getContext("webgpu");if(!e)throw Error("Root element not found, please specify it.");if(!r)throw Error("Could not get the rendering context from canvas.");return e.appendChild(t),r})(document.getElementById("root")),t=await navigator.gpu.requestAdapter();if(!t)throw Error("Could not request adapter");const r=await t.requestDevice();if(!r)throw Error("Could not request device");const n=navigator.gpu.getPreferredCanvasFormat();return e.configure({device:r,format:n}),[e,r,n]})(),i=await r.createTextureFromURL(o,"/src/assets/uv_test.png"),u=new t,s=e.createResolutionBuffer(o,new Float32Array([n.canvas.width,n.canvas.height])),{renderPipeline:c,bindGroups:p}=((e,t,r,n)=>{const{vertexBufferLayout:o}={vertexBufferLayout:{arrayStride:7*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0},{shaderLocation:1,format:"float32x2",offset:2*Float32Array.BYTES_PER_ELEMENT},{shaderLocation:2,format:"float32x3",offset:4*Float32Array.BYTES_PER_ELEMENT}],stepMode:"vertex"}},a=e.createShaderModule({code:"struct VertexInput {\r\n    @location(0) position: vec2f,\r\n    @location(1) tex_coords: vec2f,\r\n    @location(2) color: vec3f,\r\n}\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) position: vec4f,\r\n    @location(0) tex_coords: vec2f,\r\n    @location(1) color: vec4f,\r\n}\r\n\r\n@group(0) @binding(0) var<uniform> resolution: vec2f;\r\n\r\n\r\nfn to_clip_space(position: vec2f) -> vec2<f32> {\r\n    // convert the position from pixels to a 0.0 to 1.0 value\r\n    let zeroToOne = position / resolution;\r\n\r\n    // convert from 0 <-> 1 to 0 <-> 2\r\n    let zeroToTwo = zeroToOne * 2.0;\r\n\r\n    // covert from 0 <-> 2 to -1 <-> +1 (clip space)\r\n    let clipSpace = zeroToTwo - 1.0;\r\n\r\n    // results into x,y=0 is at the bottom left.\r\n\r\n    return clipSpace;\r\n}\r\n\r\n@vertex\r\nfn vertex_main(input: VertexInput) -> VertexOutput {\r\n    var output: VertexOutput;\r\n\r\n    output.position = vec4f(to_clip_space(input.position), 0.0, 1.0);\r\n    output.color = vec4f(input.color, 1.0);\r\n    output.tex_coords = input.tex_coords;\r\n\r\n    return output;\r\n}\r\n\r\n@group(1) @binding(0) var tex_sampler: sampler;\r\n@group(1) @binding(1) var tex: texture_2d<f32>;\r\n\r\n@fragment\r\nfn fragment_main(input: VertexOutput) -> @location(0) vec4f {\r\n    var texture_color = textureSample(tex, tex_sampler, input.tex_coords);\r\n    return input.color * texture_color;\r\n}\r\n",label:"Shaders.wgsl"}),{vertexState:i,fragmentState:u}=((e,t,r)=>({vertexState:{module:e,entryPoint:"vertex_main",buffers:r},fragmentState:{module:e,entryPoint:"fragment_main",targets:[{format:t,blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]}}))(a,t,[o]),{textureBindGroupLayout:s,pipelineLayout:c,resolutionBindGroupLayout:p}=(e=>{const t=e.createBindGroupLayout({label:"ResolutionBindGroupLayout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}}]}),r=e.createBindGroupLayout({label:"TextureBindGroupLayout",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}]});return{textureBindGroupLayout:r,pipelineLayout:e.createPipelineLayout({bindGroupLayouts:[t,r]}),resolutionBindGroupLayout:t}})(e),{renderPipeline:l,resolutionBindGroup:d,textureBindGroup:f}=((e,t,r,n,o)=>({resolutionBindGroup:e.createBindGroup({layout:t.resolutionBindGroupLayout,entries:[{binding:0,resource:{buffer:n.resolutionBuffer}}]}),textureBindGroup:e.createBindGroup({layout:t.textureBindGroupLayout,entries:[{binding:0,resource:o.sampler},{binding:1,resource:o.texture.createView()}]}),renderPipeline:e.createRenderPipeline({layout:t.pipelineLayout,vertex:r.vertexState,fragment:r.fragmentState,primitive:{topology:"triangle-list"}})}))(e,{pipelineLayout:c,textureBindGroupLayout:s,resolutionBindGroupLayout:p},{fragmentState:u,vertexState:i},{resolutionBuffer:n},r);return{renderPipeline:l,bindGroups:{resolutionBindGroup:d,textureBindGroup:f}}})(o,a,i,s),l=e.createVertexBuffer(o,new Float32Array(u.vertices)),d=e.createIndexBuffer(o,new Uint16Array(u.inidices));((e,t,r,n,o)=>{const a=e.createCommandEncoder(),i=a.beginRenderPass({colorAttachments:[{view:t.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:.85,g:.85,b:.85,a:1},storeOp:"store"}]});i.setPipeline(r),i.setIndexBuffer(o.indexBuffer,"uint16"),i.setVertexBuffer(0,o.vertexBuffer),i.setBindGroup(0,n.resolutionBindGroup),i.setBindGroup(1,n.textureBindGroup),i.drawIndexed(6),i.end(),e.queue.submit([a.finish()])})(o,n,c,{resolutionBindGroup:p.resolutionBindGroup,textureBindGroup:p.textureBindGroup},{vertexBuffer:l,indexBuffer:d})})()})();