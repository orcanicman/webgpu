(()=>{"use strict";class e{static createVertexBuffer(e,t){const r=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new Float32Array(r.getMappedRange()).set(t),r.unmap(),r}static createIndexBuffer(e,t){const r=e.createBuffer({size:t.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new Uint16Array(r.getMappedRange()).set(t),r.unmap(),r}}class t{vertices;inidices;constructor(){this.vertices=[-.5,-.5,0,1,1,1,1,.5,-.5,1,1,1,1,1,-.5,.5,0,0,1,1,1,.5,.5,1,0,1,1,1],this.inidices=[0,1,2,1,2,3]}}class r{texture;sampler;constructor(e,t){this.texture=e,this.sampler=t}static async createTexture(e,t){const n=e.createTexture({size:{width:t.width,height:t.height},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}),a=await createImageBitmap(t);e.queue.copyExternalImageToTexture({source:a},{texture:n},{width:t.width,height:t.height});const o=e.createSampler({magFilter:"nearest",minFilter:"linear"});return new r(n,o)}static async createTextureFromURL(e,t){const n=new Promise(((e,r)=>{const n=new Image;n.src=t,n.onload=()=>e(n),n.onerror=()=>{console.error(`Failed to load image ${t}`),r()}})),a=await n;return r.createTexture(e,a)}}(async()=>{const[n,a,o]=await(async()=>{if(!navigator.gpu)throw Error("Can not initialize gpu");const e=(e=>{const t=document.createElement("canvas");t.width=800,t.height=600;const r=t.getContext("webgpu");if(!e)throw Error("Root element not found, please specify it.");if(!r)throw Error("Could not get the rendering context from canvas.");return e.appendChild(t),r})(document.getElementById("root")),t=await navigator.gpu.requestAdapter();if(!t)throw Error("Could not request adapter");const r=await t.requestDevice();if(!r)throw Error("Could not request device");const n=navigator.gpu.getPreferredCanvasFormat();return e.configure({device:r,format:n}),[e,r,n]})(),i=await r.createTextureFromURL(a,"/src/assets/uv_test.png"),u=new t,{renderPipeline:s,textureBindGroup:c}=((e,t,r)=>{const{vertexBufferLayout:n}={vertexBufferLayout:{arrayStride:7*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0},{shaderLocation:1,format:"float32x2",offset:2*Float32Array.BYTES_PER_ELEMENT},{shaderLocation:2,format:"float32x3",offset:4*Float32Array.BYTES_PER_ELEMENT}],stepMode:"vertex"}},a=e.createShaderModule({code:"struct VertexInput {\r\n    @location(0) position: vec2f,\r\n    @location(1) tex_coords: vec2f,\r\n    @location(2) color: vec3f,\r\n}\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) position: vec4f,\r\n    @location(0) tex_coords: vec2f,\r\n    @location(1) color: vec4f,\r\n}\r\n\r\n@vertex\r\nfn vertex_main(input: VertexInput) -> VertexOutput {\r\n    var output: VertexOutput;\r\n\r\n    output.position = vec4f(input.position, 0.0, 1.0);\r\n    output.color = vec4f(input.color, 1.0);\r\n    output.tex_coords = input.tex_coords;\r\n\r\n    return output;\r\n}\r\n\r\n@group(0) @binding(0) var tex_sampler: sampler;\r\n@group(0) @binding(1) var tex: texture_2d<f32>;\r\n\r\n@fragment\r\nfn fragment_main(input: VertexOutput) -> @location(0) vec4f {\r\n    var texture_color = textureSample(tex, tex_sampler, input.tex_coords);\r\n    return input.color * texture_color;\r\n}\r\n",label:"Shaders.wgsl"}),{vertexState:o,fragmentState:i}=((e,t,r)=>({vertexState:{module:e,entryPoint:"vertex_main",buffers:r},fragmentState:{module:e,entryPoint:"fragment_main",targets:[{format:t,blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]}}))(a,t,[n]),{textureBindGroupLayout:u,pipelineLayout:s}=(e=>{const t=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}]});return{textureBindGroupLayout:t,pipelineLayout:e.createPipelineLayout({bindGroupLayouts:[t]})}})(e),{renderPipeline:c,textureBindGroup:p}=((e,t,r,n)=>({textureBindGroup:e.createBindGroup({layout:t.textureBindGroupLayout,entries:[{binding:0,resource:n.sampler},{binding:1,resource:n.texture.createView()}]}),renderPipeline:e.createRenderPipeline({layout:t.pipelineLayout,vertex:r.vertexState,fragment:r.fragmentState,primitive:{topology:"triangle-list"}})}))(e,{pipelineLayout:s,textureBindGroupLayout:u},{fragmentState:i,vertexState:o},r);return{renderPipeline:c,textureBindGroup:p}})(a,o,i);((e,t,r,n,a)=>{const o=e.createCommandEncoder(),i=o.beginRenderPass({colorAttachments:[{view:t.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:.85,g:.85,b:.85,a:1},storeOp:"store"}]});i.setPipeline(r),i.setIndexBuffer(a.indexBuffer,"uint16"),i.setVertexBuffer(0,a.vertexBuffer),i.setBindGroup(0,n),i.drawIndexed(6),i.end(),e.queue.submit([o.finish()])})(a,n,s,c,{vertexBuffer:e.createVertexBuffer(a,new Float32Array(u.vertices)),indexBuffer:e.createIndexBuffer(a,new Uint16Array(u.inidices))})})()})();